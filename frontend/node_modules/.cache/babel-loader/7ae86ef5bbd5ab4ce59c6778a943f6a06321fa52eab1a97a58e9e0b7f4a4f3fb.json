{"ast":null,"code":"// src/services/verificationService.js\n// Servicio para verificación de identidad y datos de usuario\n// FIREBASE REMOVED - TODO: Replace with backend API\n// FIREBASE REMOVED - TODO: Replace with backend API\nimport{validateCedulaFormat,validatePhoneFormat}from'../utils/validation';class VerificationService{/**\n   * Verifica la cédula de un usuario\n   * En un sistema real, esto haría una consulta a la TSE (Tribunal Supremo de Elecciones)\n   * Por ahora, solo validamos el formato\n   */async verifyCedula(userId,cedula,fullName){try{// Validar formato\nconst validation=validateCedulaFormat(cedula);if(!validation.valid){return{success:false,error:validation.error};}// En un sistema real, aquí haríamos la consulta a la TSE\n// Por ahora, simulamos una verificación exitosa si el formato es válido\nconst isValid=await this.simulateTSEVerification(validation.cleanCedula,fullName);if(isValid){// Actualizar estado de verificación en Firebase\nawait updateDoc(doc(/* db */null,'users',userId),{'verification.identity':true,'verification.cedulaVerifiedAt':new Date(),'verification.cedulaNumber':validation.formatted,'verificationStatus.cedula':true,'fullName':fullName,'updatedAt':new Date()});return{success:true,message:'Cédula verificada exitosamente'};}else{return{success:false,error:'No se pudo verificar la cédula. Verifica que los datos sean correctos.'};}}catch(error){console.error('Error verificando cédula:',error);return{success:false,error:'Error interno del servidor'};}}/**\n   * Verifica el número de teléfono\n   * En un sistema real, enviaría un SMS con código de verificación\n   */async verifyPhone(userId,phone){try{// Validar formato\nconst validation=validatePhoneFormat(phone);if(!validation.valid){return{success:false,error:validation.error};}// Generar código de verificación\nconst verificationCode=this.generateVerificationCode();// Guardar código temporalmente en Firebase (expira en 5 minutos)\nconst expiresAt=new Date(Date.now()+5*60*1000);await updateDoc(doc(/* db */null,'users',userId),{'phoneVerification.code':verificationCode,'phoneVerification.expiresAt':expiresAt,'phoneVerification.phone':validation.formatted,'phoneVerification.attempts':0,'updatedAt':new Date()});// En un sistema real, aquí enviaríamos el SMS\nconsole.log(`Código de verificación para ${validation.formatted}: ${verificationCode}`);return{success:true,message:`Código enviado a ${validation.formatted}`,// En desarrollo, devolvemos el código para testing\ndevelopmentCode:process.env.NODE_ENV==='development'?verificationCode:undefined};}catch(error){console.error('Error enviando código de verificación:',error);return{success:false,error:'Error enviando código de verificación'};}}/**\n   * Confirma el código de verificación de teléfono\n   */async confirmPhoneVerification(userId,code){try{const userDoc=await getDoc(doc(/* db */null,'users',userId));if(!userDoc.exists()){return{success:false,error:'Usuario no encontrado'};}const userData=userDoc.data();const phoneVerification=userData.phoneVerification;if(!phoneVerification||!phoneVerification.code){return{success:false,error:'No hay verificación pendiente'};}// Verificar si el código expiró\nconst now=new Date();if(now>phoneVerification.expiresAt.toDate()){return{success:false,error:'El código ha expirado'};}// Verificar intentos\nif(phoneVerification.attempts>=3){return{success:false,error:'Demasiados intentos. Solicita un nuevo código'};}// Verificar código\nif(code!==phoneVerification.code){// Incrementar intentos\nawait updateDoc(doc(/* db */null,'users',userId),{'phoneVerification.attempts':(phoneVerification.attempts||0)+1,'updatedAt':new Date()});return{success:false,error:'Código incorrecto'};}// Código correcto - marcar como verificado\nawait updateDoc(doc(/* db */null,'users',userId),{'verification.phone':true,'verification.phoneVerifiedAt':new Date(),'verificationStatus.phone':true,'phone':phoneVerification.phone,// Limpiar datos temporales\n'phoneVerification':null,'updatedAt':new Date()});return{success:true,message:'Teléfono verificado exitosamente'};}catch(error){console.error('Error confirmando verificación:',error);return{success:false,error:'Error interno del servidor'};}}/**\n   * Obtiene el estado de verificación de un usuario\n   */async getVerificationStatus(userId){try{var _userData$verificatio,_userData$verificatio2,_userData$verificatio3,_userData$verificatio4,_userData$verificatio5,_userData$verificatio6;const userDoc=await getDoc(doc(/* db */null,'users',userId));if(!userDoc.exists()){return null;}const userData=userDoc.data();return{email:((_userData$verificatio=userData.verification)===null||_userData$verificatio===void 0?void 0:_userData$verificatio.email)||false,phone:((_userData$verificatio2=userData.verification)===null||_userData$verificatio2===void 0?void 0:_userData$verificatio2.phone)||false,identity:((_userData$verificatio3=userData.verification)===null||_userData$verificatio3===void 0?void 0:_userData$verificatio3.identity)||false,isFullyVerified:((_userData$verificatio4=userData.verification)===null||_userData$verificatio4===void 0?void 0:_userData$verificatio4.email)&&((_userData$verificatio5=userData.verification)===null||_userData$verificatio5===void 0?void 0:_userData$verificatio5.phone)&&((_userData$verificatio6=userData.verification)===null||_userData$verificatio6===void 0?void 0:_userData$verificatio6.identity)||false};}catch(error){console.error('Error obteniendo estado de verificación:',error);return null;}}/**\n   * Verifica si un usuario puede realizar transacciones P2P\n   * Requiere teléfono y cédula verificados\n   */async canUseP2P(userId){const status=await this.getVerificationStatus(userId);return status&&status.phone&&status.identity;}// Utilidades privadas\n/**\n   * Simula verificación con TSE\n   * En un sistema real, esto haría una consulta a la API del TSE\n   */async simulateTSEVerification(cedula,fullName){// Simular delay de API\nawait new Promise(resolve=>setTimeout(resolve,1000));// En desarrollo, aceptamos cualquier cédula con formato válido\nif(process.env.NODE_ENV==='development'){return true;}// En producción, aquí haríamos la consulta real a TSE\n// return await this.queryTSEDatabase(cedula, fullName);\nreturn true;// Por ahora, aceptamos todas\n}/**\n   * Genera código de verificación de 6 dígitos\n   */generateVerificationCode(){return Math.floor(100000+Math.random()*900000).toString();}/**\n   * Envía SMS (simulado)\n   * En producción, usaría un servicio como Twilio o similar\n   */async sendSMS(phone,message){// En desarrollo, solo log\nif(process.env.NODE_ENV==='development'){console.log(`SMS a ${phone}: ${message}`);return{success:true};}// En producción, integración con servicio SMS\n// return await this.smsProvider.send(phone, message);\nreturn{success:true};// Por ahora\n}/**\n   * Limpia códigos de verificación expirados\n   * Esta función debería ejecutarse periódicamente via Cloud Function\n   */async cleanupExpiredCodes(){// Esta lógica estaría en una Cloud Function\nconsole.log('Limpiando códigos expirados...');}}// Instancia singleton\nconst verificationService=new VerificationService();export default verificationService;","map":{"version":3,"names":["validateCedulaFormat","validatePhoneFormat","VerificationService","verifyCedula","userId","cedula","fullName","validation","valid","success","error","isValid","simulateTSEVerification","cleanCedula","updateDoc","doc","Date","formatted","message","console","verifyPhone","phone","verificationCode","generateVerificationCode","expiresAt","now","log","developmentCode","process","env","NODE_ENV","undefined","confirmPhoneVerification","code","userDoc","getDoc","exists","userData","data","phoneVerification","toDate","attempts","getVerificationStatus","_userData$verificatio","_userData$verificatio2","_userData$verificatio3","_userData$verificatio4","_userData$verificatio5","_userData$verificatio6","email","verification","identity","isFullyVerified","canUseP2P","status","Promise","resolve","setTimeout","Math","floor","random","toString","sendSMS","cleanupExpiredCodes","verificationService"],"sources":["/home/frodev/Downloads/FroDev-CR-TropicalTCGPlayers/src/services/verificationService.js"],"sourcesContent":["// src/services/verificationService.js\n// Servicio para verificación de identidad y datos de usuario\n\n// FIREBASE REMOVED - TODO: Replace with backend API\n// FIREBASE REMOVED - TODO: Replace with backend API\nimport { validateCedulaFormat, validatePhoneFormat } from '../utils/validation';\n\nclass VerificationService {\n  \n  /**\n   * Verifica la cédula de un usuario\n   * En un sistema real, esto haría una consulta a la TSE (Tribunal Supremo de Elecciones)\n   * Por ahora, solo validamos el formato\n   */\n  async verifyCedula(userId, cedula, fullName) {\n    try {\n      // Validar formato\n      const validation = validateCedulaFormat(cedula);\n      if (!validation.valid) {\n        return {\n          success: false,\n          error: validation.error\n        };\n      }\n\n      // En un sistema real, aquí haríamos la consulta a la TSE\n      // Por ahora, simulamos una verificación exitosa si el formato es válido\n      const isValid = await this.simulateTSEVerification(validation.cleanCedula, fullName);\n      \n      if (isValid) {\n        // Actualizar estado de verificación en Firebase\n        await updateDoc(doc(/* db */ null, 'users', userId), {\n          'verification.identity': true,\n          'verification.cedulaVerifiedAt': new Date(),\n          'verification.cedulaNumber': validation.formatted,\n          'verificationStatus.cedula': true,\n          'fullName': fullName,\n          'updatedAt': new Date()\n        });\n\n        return {\n          success: true,\n          message: 'Cédula verificada exitosamente'\n        };\n      } else {\n        return {\n          success: false,\n          error: 'No se pudo verificar la cédula. Verifica que los datos sean correctos.'\n        };\n      }\n\n    } catch (error) {\n      console.error('Error verificando cédula:', error);\n      return {\n        success: false,\n        error: 'Error interno del servidor'\n      };\n    }\n  }\n\n  /**\n   * Verifica el número de teléfono\n   * En un sistema real, enviaría un SMS con código de verificación\n   */\n  async verifyPhone(userId, phone) {\n    try {\n      // Validar formato\n      const validation = validatePhoneFormat(phone);\n      if (!validation.valid) {\n        return {\n          success: false,\n          error: validation.error\n        };\n      }\n\n      // Generar código de verificación\n      const verificationCode = this.generateVerificationCode();\n      \n      // Guardar código temporalmente en Firebase (expira en 5 minutos)\n      const expiresAt = new Date(Date.now() + 5 * 60 * 1000);\n      \n      await updateDoc(doc(/* db */ null, 'users', userId), {\n        'phoneVerification.code': verificationCode,\n        'phoneVerification.expiresAt': expiresAt,\n        'phoneVerification.phone': validation.formatted,\n        'phoneVerification.attempts': 0,\n        'updatedAt': new Date()\n      });\n\n      // En un sistema real, aquí enviaríamos el SMS\n      console.log(`Código de verificación para ${validation.formatted}: ${verificationCode}`);\n      \n      return {\n        success: true,\n        message: `Código enviado a ${validation.formatted}`,\n        // En desarrollo, devolvemos el código para testing\n        developmentCode: process.env.NODE_ENV === 'development' ? verificationCode : undefined\n      };\n\n    } catch (error) {\n      console.error('Error enviando código de verificación:', error);\n      return {\n        success: false,\n        error: 'Error enviando código de verificación'\n      };\n    }\n  }\n\n  /**\n   * Confirma el código de verificación de teléfono\n   */\n  async confirmPhoneVerification(userId, code) {\n    try {\n      const userDoc = await getDoc(doc(/* db */ null, 'users', userId));\n      if (!userDoc.exists()) {\n        return { success: false, error: 'Usuario no encontrado' };\n      }\n\n      const userData = userDoc.data();\n      const phoneVerification = userData.phoneVerification;\n\n      if (!phoneVerification || !phoneVerification.code) {\n        return { success: false, error: 'No hay verificación pendiente' };\n      }\n\n      // Verificar si el código expiró\n      const now = new Date();\n      if (now > phoneVerification.expiresAt.toDate()) {\n        return { success: false, error: 'El código ha expirado' };\n      }\n\n      // Verificar intentos\n      if (phoneVerification.attempts >= 3) {\n        return { success: false, error: 'Demasiados intentos. Solicita un nuevo código' };\n      }\n\n      // Verificar código\n      if (code !== phoneVerification.code) {\n        // Incrementar intentos\n        await updateDoc(doc(/* db */ null, 'users', userId), {\n          'phoneVerification.attempts': (phoneVerification.attempts || 0) + 1,\n          'updatedAt': new Date()\n        });\n\n        return { success: false, error: 'Código incorrecto' };\n      }\n\n      // Código correcto - marcar como verificado\n      await updateDoc(doc(/* db */ null, 'users', userId), {\n        'verification.phone': true,\n        'verification.phoneVerifiedAt': new Date(),\n        'verificationStatus.phone': true,\n        'phone': phoneVerification.phone,\n        // Limpiar datos temporales\n        'phoneVerification': null,\n        'updatedAt': new Date()\n      });\n\n      return {\n        success: true,\n        message: 'Teléfono verificado exitosamente'\n      };\n\n    } catch (error) {\n      console.error('Error confirmando verificación:', error);\n      return {\n        success: false,\n        error: 'Error interno del servidor'\n      };\n    }\n  }\n\n  /**\n   * Obtiene el estado de verificación de un usuario\n   */\n  async getVerificationStatus(userId) {\n    try {\n      const userDoc = await getDoc(doc(/* db */ null, 'users', userId));\n      if (!userDoc.exists()) {\n        return null;\n      }\n\n      const userData = userDoc.data();\n      return {\n        email: userData.verification?.email || false,\n        phone: userData.verification?.phone || false,\n        identity: userData.verification?.identity || false,\n        isFullyVerified: (userData.verification?.email && userData.verification?.phone && userData.verification?.identity) || false\n      };\n    } catch (error) {\n      console.error('Error obteniendo estado de verificación:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Verifica si un usuario puede realizar transacciones P2P\n   * Requiere teléfono y cédula verificados\n   */\n  async canUseP2P(userId) {\n    const status = await this.getVerificationStatus(userId);\n    return status && status.phone && status.identity;\n  }\n\n  // Utilidades privadas\n\n  /**\n   * Simula verificación con TSE\n   * En un sistema real, esto haría una consulta a la API del TSE\n   */\n  async simulateTSEVerification(cedula, fullName) {\n    // Simular delay de API\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // En desarrollo, aceptamos cualquier cédula con formato válido\n    if (process.env.NODE_ENV === 'development') {\n      return true;\n    }\n\n    // En producción, aquí haríamos la consulta real a TSE\n    // return await this.queryTSEDatabase(cedula, fullName);\n    \n    return true; // Por ahora, aceptamos todas\n  }\n\n  /**\n   * Genera código de verificación de 6 dígitos\n   */\n  generateVerificationCode() {\n    return Math.floor(100000 + Math.random() * 900000).toString();\n  }\n\n  /**\n   * Envía SMS (simulado)\n   * En producción, usaría un servicio como Twilio o similar\n   */\n  async sendSMS(phone, message) {\n    // En desarrollo, solo log\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`SMS a ${phone}: ${message}`);\n      return { success: true };\n    }\n\n    // En producción, integración con servicio SMS\n    // return await this.smsProvider.send(phone, message);\n    \n    return { success: true }; // Por ahora\n  }\n\n  /**\n   * Limpia códigos de verificación expirados\n   * Esta función debería ejecutarse periódicamente via Cloud Function\n   */\n  async cleanupExpiredCodes() {\n    // Esta lógica estaría en una Cloud Function\n    console.log('Limpiando códigos expirados...');\n  }\n}\n\n// Instancia singleton\nconst verificationService = new VerificationService();\n\nexport default verificationService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}