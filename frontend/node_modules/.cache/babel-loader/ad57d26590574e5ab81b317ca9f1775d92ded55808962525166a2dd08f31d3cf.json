{"ast":null,"code":"// src/services/verificationService.js\n// Servicio para verificación de identidad y datos de usuario\n\nimport { doc, updateDoc, getDoc } from 'firebase/firestore';\nimport { db } from '../firebase';\nimport { validateCedulaFormat, validatePhoneFormat } from '../utils/validation';\nclass VerificationService {\n  /**\n   * Verifica la cédula de un usuario\n   * En un sistema real, esto haría una consulta a la TSE (Tribunal Supremo de Elecciones)\n   * Por ahora, solo validamos el formato\n   */\n  async verifyCedula(userId, cedula, fullName) {\n    try {\n      // Validar formato\n      const validation = validateCedulaFormat(cedula);\n      if (!validation.valid) {\n        return {\n          success: false,\n          error: validation.error\n        };\n      }\n\n      // En un sistema real, aquí haríamos la consulta a la TSE\n      // Por ahora, simulamos una verificación exitosa si el formato es válido\n      const isValid = await this.simulateTSEVerification(validation.cleanCedula, fullName);\n      if (isValid) {\n        // Actualizar estado de verificación en Firebase\n        await updateDoc(doc(db, 'users', userId), {\n          'verification.identity': true,\n          'verification.cedulaVerifiedAt': new Date(),\n          'verification.cedulaNumber': validation.formatted,\n          'verificationStatus.cedula': true,\n          'fullName': fullName,\n          'updatedAt': new Date()\n        });\n        return {\n          success: true,\n          message: 'Cédula verificada exitosamente'\n        };\n      } else {\n        return {\n          success: false,\n          error: 'No se pudo verificar la cédula. Verifica que los datos sean correctos.'\n        };\n      }\n    } catch (error) {\n      console.error('Error verificando cédula:', error);\n      return {\n        success: false,\n        error: 'Error interno del servidor'\n      };\n    }\n  }\n\n  /**\n   * Verifica el número de teléfono\n   * En un sistema real, enviaría un SMS con código de verificación\n   */\n  async verifyPhone(userId, phone) {\n    try {\n      // Validar formato\n      const validation = validatePhoneFormat(phone);\n      if (!validation.valid) {\n        return {\n          success: false,\n          error: validation.error\n        };\n      }\n\n      // Generar código de verificación\n      const verificationCode = this.generateVerificationCode();\n\n      // Guardar código temporalmente en Firebase (expira en 5 minutos)\n      const expiresAt = new Date(Date.now() + 5 * 60 * 1000);\n      await updateDoc(doc(db, 'users', userId), {\n        'phoneVerification.code': verificationCode,\n        'phoneVerification.expiresAt': expiresAt,\n        'phoneVerification.phone': validation.formatted,\n        'phoneVerification.attempts': 0,\n        'updatedAt': new Date()\n      });\n\n      // En un sistema real, aquí enviaríamos el SMS\n      console.log(`Código de verificación para ${validation.formatted}: ${verificationCode}`);\n      return {\n        success: true,\n        message: `Código enviado a ${validation.formatted}`,\n        // En desarrollo, devolvemos el código para testing\n        developmentCode: process.env.NODE_ENV === 'development' ? verificationCode : undefined\n      };\n    } catch (error) {\n      console.error('Error enviando código de verificación:', error);\n      return {\n        success: false,\n        error: 'Error enviando código de verificación'\n      };\n    }\n  }\n\n  /**\n   * Confirma el código de verificación de teléfono\n   */\n  async confirmPhoneVerification(userId, code) {\n    try {\n      const userDoc = await getDoc(doc(db, 'users', userId));\n      if (!userDoc.exists()) {\n        return {\n          success: false,\n          error: 'Usuario no encontrado'\n        };\n      }\n      const userData = userDoc.data();\n      const phoneVerification = userData.phoneVerification;\n      if (!phoneVerification || !phoneVerification.code) {\n        return {\n          success: false,\n          error: 'No hay verificación pendiente'\n        };\n      }\n\n      // Verificar si el código expiró\n      const now = new Date();\n      if (now > phoneVerification.expiresAt.toDate()) {\n        return {\n          success: false,\n          error: 'El código ha expirado'\n        };\n      }\n\n      // Verificar intentos\n      if (phoneVerification.attempts >= 3) {\n        return {\n          success: false,\n          error: 'Demasiados intentos. Solicita un nuevo código'\n        };\n      }\n\n      // Verificar código\n      if (code !== phoneVerification.code) {\n        // Incrementar intentos\n        await updateDoc(doc(db, 'users', userId), {\n          'phoneVerification.attempts': (phoneVerification.attempts || 0) + 1,\n          'updatedAt': new Date()\n        });\n        return {\n          success: false,\n          error: 'Código incorrecto'\n        };\n      }\n\n      // Código correcto - marcar como verificado\n      await updateDoc(doc(db, 'users', userId), {\n        'verification.phone': true,\n        'verification.phoneVerifiedAt': new Date(),\n        'verificationStatus.phone': true,\n        'phone': phoneVerification.phone,\n        // Limpiar datos temporales\n        'phoneVerification': null,\n        'updatedAt': new Date()\n      });\n      return {\n        success: true,\n        message: 'Teléfono verificado exitosamente'\n      };\n    } catch (error) {\n      console.error('Error confirmando verificación:', error);\n      return {\n        success: false,\n        error: 'Error interno del servidor'\n      };\n    }\n  }\n\n  /**\n   * Obtiene el estado de verificación de un usuario\n   */\n  async getVerificationStatus(userId) {\n    try {\n      var _userData$verificatio, _userData$verificatio2, _userData$verificatio3, _userData$verificatio4, _userData$verificatio5, _userData$verificatio6;\n      const userDoc = await getDoc(doc(db, 'users', userId));\n      if (!userDoc.exists()) {\n        return null;\n      }\n      const userData = userDoc.data();\n      return {\n        email: ((_userData$verificatio = userData.verification) === null || _userData$verificatio === void 0 ? void 0 : _userData$verificatio.email) || false,\n        phone: ((_userData$verificatio2 = userData.verification) === null || _userData$verificatio2 === void 0 ? void 0 : _userData$verificatio2.phone) || false,\n        identity: ((_userData$verificatio3 = userData.verification) === null || _userData$verificatio3 === void 0 ? void 0 : _userData$verificatio3.identity) || false,\n        isFullyVerified: ((_userData$verificatio4 = userData.verification) === null || _userData$verificatio4 === void 0 ? void 0 : _userData$verificatio4.email) && ((_userData$verificatio5 = userData.verification) === null || _userData$verificatio5 === void 0 ? void 0 : _userData$verificatio5.phone) && ((_userData$verificatio6 = userData.verification) === null || _userData$verificatio6 === void 0 ? void 0 : _userData$verificatio6.identity) || false\n      };\n    } catch (error) {\n      console.error('Error obteniendo estado de verificación:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Verifica si un usuario puede realizar transacciones P2P\n   * Requiere teléfono y cédula verificados\n   */\n  async canUseP2P(userId) {\n    const status = await this.getVerificationStatus(userId);\n    return status && status.phone && status.identity;\n  }\n\n  // Utilidades privadas\n\n  /**\n   * Simula verificación con TSE\n   * En un sistema real, esto haría una consulta a la API del TSE\n   */\n  async simulateTSEVerification(cedula, fullName) {\n    // Simular delay de API\n    await new Promise(resolve => setTimeout(resolve, 1000));\n\n    // En desarrollo, aceptamos cualquier cédula con formato válido\n    if (process.env.NODE_ENV === 'development') {\n      return true;\n    }\n\n    // En producción, aquí haríamos la consulta real a TSE\n    // return await this.queryTSEDatabase(cedula, fullName);\n\n    return true; // Por ahora, aceptamos todas\n  }\n\n  /**\n   * Genera código de verificación de 6 dígitos\n   */\n  generateVerificationCode() {\n    return Math.floor(100000 + Math.random() * 900000).toString();\n  }\n\n  /**\n   * Envía SMS (simulado)\n   * En producción, usaría un servicio como Twilio o similar\n   */\n  async sendSMS(phone, message) {\n    // En desarrollo, solo log\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`SMS a ${phone}: ${message}`);\n      return {\n        success: true\n      };\n    }\n\n    // En producción, integración con servicio SMS\n    // return await this.smsProvider.send(phone, message);\n\n    return {\n      success: true\n    }; // Por ahora\n  }\n\n  /**\n   * Limpia códigos de verificación expirados\n   * Esta función debería ejecutarse periódicamente via Cloud Function\n   */\n  async cleanupExpiredCodes() {\n    // Esta lógica estaría en una Cloud Function\n    console.log('Limpiando códigos expirados...');\n  }\n}\n\n// Instancia singleton\nconst verificationService = new VerificationService();\nexport default verificationService;","map":{"version":3,"names":["doc","updateDoc","getDoc","db","validateCedulaFormat","validatePhoneFormat","VerificationService","verifyCedula","userId","cedula","fullName","validation","valid","success","error","isValid","simulateTSEVerification","cleanCedula","Date","formatted","message","console","verifyPhone","phone","verificationCode","generateVerificationCode","expiresAt","now","log","developmentCode","process","env","NODE_ENV","undefined","confirmPhoneVerification","code","userDoc","exists","userData","data","phoneVerification","toDate","attempts","getVerificationStatus","_userData$verificatio","_userData$verificatio2","_userData$verificatio3","_userData$verificatio4","_userData$verificatio5","_userData$verificatio6","email","verification","identity","isFullyVerified","canUseP2P","status","Promise","resolve","setTimeout","Math","floor","random","toString","sendSMS","cleanupExpiredCodes","verificationService"],"sources":["/home/frodev/Downloads/FroDev-CR-TropicalTCGPlayers/src/services/verificationService.js"],"sourcesContent":["// src/services/verificationService.js\n// Servicio para verificación de identidad y datos de usuario\n\nimport { doc, updateDoc, getDoc } from 'firebase/firestore';\nimport { db } from '../firebase';\nimport { validateCedulaFormat, validatePhoneFormat } from '../utils/validation';\n\nclass VerificationService {\n  \n  /**\n   * Verifica la cédula de un usuario\n   * En un sistema real, esto haría una consulta a la TSE (Tribunal Supremo de Elecciones)\n   * Por ahora, solo validamos el formato\n   */\n  async verifyCedula(userId, cedula, fullName) {\n    try {\n      // Validar formato\n      const validation = validateCedulaFormat(cedula);\n      if (!validation.valid) {\n        return {\n          success: false,\n          error: validation.error\n        };\n      }\n\n      // En un sistema real, aquí haríamos la consulta a la TSE\n      // Por ahora, simulamos una verificación exitosa si el formato es válido\n      const isValid = await this.simulateTSEVerification(validation.cleanCedula, fullName);\n      \n      if (isValid) {\n        // Actualizar estado de verificación en Firebase\n        await updateDoc(doc(db, 'users', userId), {\n          'verification.identity': true,\n          'verification.cedulaVerifiedAt': new Date(),\n          'verification.cedulaNumber': validation.formatted,\n          'verificationStatus.cedula': true,\n          'fullName': fullName,\n          'updatedAt': new Date()\n        });\n\n        return {\n          success: true,\n          message: 'Cédula verificada exitosamente'\n        };\n      } else {\n        return {\n          success: false,\n          error: 'No se pudo verificar la cédula. Verifica que los datos sean correctos.'\n        };\n      }\n\n    } catch (error) {\n      console.error('Error verificando cédula:', error);\n      return {\n        success: false,\n        error: 'Error interno del servidor'\n      };\n    }\n  }\n\n  /**\n   * Verifica el número de teléfono\n   * En un sistema real, enviaría un SMS con código de verificación\n   */\n  async verifyPhone(userId, phone) {\n    try {\n      // Validar formato\n      const validation = validatePhoneFormat(phone);\n      if (!validation.valid) {\n        return {\n          success: false,\n          error: validation.error\n        };\n      }\n\n      // Generar código de verificación\n      const verificationCode = this.generateVerificationCode();\n      \n      // Guardar código temporalmente en Firebase (expira en 5 minutos)\n      const expiresAt = new Date(Date.now() + 5 * 60 * 1000);\n      \n      await updateDoc(doc(db, 'users', userId), {\n        'phoneVerification.code': verificationCode,\n        'phoneVerification.expiresAt': expiresAt,\n        'phoneVerification.phone': validation.formatted,\n        'phoneVerification.attempts': 0,\n        'updatedAt': new Date()\n      });\n\n      // En un sistema real, aquí enviaríamos el SMS\n      console.log(`Código de verificación para ${validation.formatted}: ${verificationCode}`);\n      \n      return {\n        success: true,\n        message: `Código enviado a ${validation.formatted}`,\n        // En desarrollo, devolvemos el código para testing\n        developmentCode: process.env.NODE_ENV === 'development' ? verificationCode : undefined\n      };\n\n    } catch (error) {\n      console.error('Error enviando código de verificación:', error);\n      return {\n        success: false,\n        error: 'Error enviando código de verificación'\n      };\n    }\n  }\n\n  /**\n   * Confirma el código de verificación de teléfono\n   */\n  async confirmPhoneVerification(userId, code) {\n    try {\n      const userDoc = await getDoc(doc(db, 'users', userId));\n      if (!userDoc.exists()) {\n        return { success: false, error: 'Usuario no encontrado' };\n      }\n\n      const userData = userDoc.data();\n      const phoneVerification = userData.phoneVerification;\n\n      if (!phoneVerification || !phoneVerification.code) {\n        return { success: false, error: 'No hay verificación pendiente' };\n      }\n\n      // Verificar si el código expiró\n      const now = new Date();\n      if (now > phoneVerification.expiresAt.toDate()) {\n        return { success: false, error: 'El código ha expirado' };\n      }\n\n      // Verificar intentos\n      if (phoneVerification.attempts >= 3) {\n        return { success: false, error: 'Demasiados intentos. Solicita un nuevo código' };\n      }\n\n      // Verificar código\n      if (code !== phoneVerification.code) {\n        // Incrementar intentos\n        await updateDoc(doc(db, 'users', userId), {\n          'phoneVerification.attempts': (phoneVerification.attempts || 0) + 1,\n          'updatedAt': new Date()\n        });\n\n        return { success: false, error: 'Código incorrecto' };\n      }\n\n      // Código correcto - marcar como verificado\n      await updateDoc(doc(db, 'users', userId), {\n        'verification.phone': true,\n        'verification.phoneVerifiedAt': new Date(),\n        'verificationStatus.phone': true,\n        'phone': phoneVerification.phone,\n        // Limpiar datos temporales\n        'phoneVerification': null,\n        'updatedAt': new Date()\n      });\n\n      return {\n        success: true,\n        message: 'Teléfono verificado exitosamente'\n      };\n\n    } catch (error) {\n      console.error('Error confirmando verificación:', error);\n      return {\n        success: false,\n        error: 'Error interno del servidor'\n      };\n    }\n  }\n\n  /**\n   * Obtiene el estado de verificación de un usuario\n   */\n  async getVerificationStatus(userId) {\n    try {\n      const userDoc = await getDoc(doc(db, 'users', userId));\n      if (!userDoc.exists()) {\n        return null;\n      }\n\n      const userData = userDoc.data();\n      return {\n        email: userData.verification?.email || false,\n        phone: userData.verification?.phone || false,\n        identity: userData.verification?.identity || false,\n        isFullyVerified: (userData.verification?.email && userData.verification?.phone && userData.verification?.identity) || false\n      };\n    } catch (error) {\n      console.error('Error obteniendo estado de verificación:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Verifica si un usuario puede realizar transacciones P2P\n   * Requiere teléfono y cédula verificados\n   */\n  async canUseP2P(userId) {\n    const status = await this.getVerificationStatus(userId);\n    return status && status.phone && status.identity;\n  }\n\n  // Utilidades privadas\n\n  /**\n   * Simula verificación con TSE\n   * En un sistema real, esto haría una consulta a la API del TSE\n   */\n  async simulateTSEVerification(cedula, fullName) {\n    // Simular delay de API\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    // En desarrollo, aceptamos cualquier cédula con formato válido\n    if (process.env.NODE_ENV === 'development') {\n      return true;\n    }\n\n    // En producción, aquí haríamos la consulta real a TSE\n    // return await this.queryTSEDatabase(cedula, fullName);\n    \n    return true; // Por ahora, aceptamos todas\n  }\n\n  /**\n   * Genera código de verificación de 6 dígitos\n   */\n  generateVerificationCode() {\n    return Math.floor(100000 + Math.random() * 900000).toString();\n  }\n\n  /**\n   * Envía SMS (simulado)\n   * En producción, usaría un servicio como Twilio o similar\n   */\n  async sendSMS(phone, message) {\n    // En desarrollo, solo log\n    if (process.env.NODE_ENV === 'development') {\n      console.log(`SMS a ${phone}: ${message}`);\n      return { success: true };\n    }\n\n    // En producción, integración con servicio SMS\n    // return await this.smsProvider.send(phone, message);\n    \n    return { success: true }; // Por ahora\n  }\n\n  /**\n   * Limpia códigos de verificación expirados\n   * Esta función debería ejecutarse periódicamente via Cloud Function\n   */\n  async cleanupExpiredCodes() {\n    // Esta lógica estaría en una Cloud Function\n    console.log('Limpiando códigos expirados...');\n  }\n}\n\n// Instancia singleton\nconst verificationService = new VerificationService();\n\nexport default verificationService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}