{"ast":null,"code":"// src/scripts/cleanDatabase.js\n// Script para limpiar completamente la base de datos Firebase\n// ‚ö†Ô∏è DEPRECADO: Este archivo ya no se usa despu√©s de la migraci√≥n a Node.js + MongoDB\n// TODO: Eliminar este archivo o crear equivalente para MongoDB\n\n// Comentado Firebase - ya no se usa\n// import { db } from '../firebase';\n// import { collection, getDocs, deleteDoc, doc, writeBatch } from 'firebase/firestore';\n\nexport async function cleanDatabase() {\n  console.log('üßπ Iniciando limpieza completa de la base de datos...');\n  const collections = ['users', 'listings', 'transactions', 'notifications', 'ratings', 'disputes', 'binders'];\n  try {\n    let totalDeleted = 0;\n    for (const collectionName of collections) {\n      console.log(`üóëÔ∏è Limpiando collection: ${collectionName}`);\n      const collectionRef = collection(db, collectionName);\n      const snapshot = await getDocs(collectionRef);\n      if (snapshot.empty) {\n        console.log(`‚úÖ Collection ${collectionName} ya est√° vac√≠a`);\n        continue;\n      }\n\n      // Usar batch para eliminar documentos en grupos de 500\n      const docs = snapshot.docs;\n      console.log(`üìä Encontrados ${docs.length} documentos en ${collectionName}`);\n      const batchSize = 500;\n      for (let i = 0; i < docs.length; i += batchSize) {\n        const batch = writeBatch(db);\n        const batchDocs = docs.slice(i, i + batchSize);\n        batchDocs.forEach(document => {\n          batch.delete(doc(db, collectionName, document.id));\n        });\n        await batch.commit();\n        totalDeleted += batchDocs.length;\n        console.log(`‚úÖ Eliminados ${batchDocs.length} documentos de ${collectionName}`);\n      }\n    }\n    console.log(`üéâ Limpieza completa! Total de documentos eliminados: ${totalDeleted}`);\n    return true;\n  } catch (error) {\n    console.error('‚ùå Error durante la limpieza:', error);\n    throw error;\n  }\n}\nexport async function createInitialStructures() {\n  console.log('üèóÔ∏è Creando estructuras iniciales...');\n  try {\n    // No necesitamos crear documentos, solo las collections se crear√°n autom√°ticamente\n    // cuando agregemos el primer documento a cada una\n\n    console.log('‚úÖ Estructuras iniciales listas');\n    console.log('üìù Las collections se crear√°n autom√°ticamente al agregar datos');\n    return true;\n  } catch (error) {\n    console.error('‚ùå Error creando estructuras:', error);\n    throw error;\n  }\n}\n\n// Funci√≥n para crear datos de prueba\nexport async function createTestData() {\n  console.log('üß™ Creando datos de prueba...');\n\n  // Esta funci√≥n la implementaremos despu√©s de la limpieza\n  return true;\n}\n\n// Funci√≥n principal que ejecuta todo el proceso\nexport async function resetDatabaseForP2P() {\n  try {\n    console.log('üöÄ Iniciando reset completo de base de datos para P2P...');\n\n    // Paso 1: Limpiar todo\n    await cleanDatabase();\n\n    // Paso 2: Crear estructuras\n    await createInitialStructures();\n\n    // Paso 3: Crear datos de prueba (opcional)\n    // await createTestData();\n\n    console.log('üéâ ¬°Reset completo exitoso!');\n    console.log('üìã La base de datos est√° lista para el sistema P2P');\n    return true;\n  } catch (error) {\n    console.error('‚ùå Error en el reset de base de datos:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["cleanDatabase","console","log","collections","totalDeleted","collectionName","collectionRef","collection","db","snapshot","getDocs","empty","docs","length","batchSize","i","batch","writeBatch","batchDocs","slice","forEach","document","delete","doc","id","commit","error","createInitialStructures","createTestData","resetDatabaseForP2P"],"sources":["/home/frodev/Downloads/FroDev-CR-TropicalTCGPlayers/src/scripts/cleanDatabase.js"],"sourcesContent":["// src/scripts/cleanDatabase.js\n// Script para limpiar completamente la base de datos Firebase\n// ‚ö†Ô∏è DEPRECADO: Este archivo ya no se usa despu√©s de la migraci√≥n a Node.js + MongoDB\n// TODO: Eliminar este archivo o crear equivalente para MongoDB\n\n// Comentado Firebase - ya no se usa\n// import { db } from '../firebase';\n// import { collection, getDocs, deleteDoc, doc, writeBatch } from 'firebase/firestore';\n\nexport async function cleanDatabase() {\n  console.log('üßπ Iniciando limpieza completa de la base de datos...');\n  \n  const collections = [\n    'users',\n    'listings', \n    'transactions',\n    'notifications',\n    'ratings',\n    'disputes',\n    'binders'\n  ];\n\n  try {\n    let totalDeleted = 0;\n\n    for (const collectionName of collections) {\n      console.log(`üóëÔ∏è Limpiando collection: ${collectionName}`);\n      \n      const collectionRef = collection(db, collectionName);\n      const snapshot = await getDocs(collectionRef);\n      \n      if (snapshot.empty) {\n        console.log(`‚úÖ Collection ${collectionName} ya est√° vac√≠a`);\n        continue;\n      }\n\n      // Usar batch para eliminar documentos en grupos de 500\n      const docs = snapshot.docs;\n      console.log(`üìä Encontrados ${docs.length} documentos en ${collectionName}`);\n      \n      const batchSize = 500;\n      for (let i = 0; i < docs.length; i += batchSize) {\n        const batch = writeBatch(db);\n        const batchDocs = docs.slice(i, i + batchSize);\n        \n        batchDocs.forEach((document) => {\n          batch.delete(doc(db, collectionName, document.id));\n        });\n        \n        await batch.commit();\n        totalDeleted += batchDocs.length;\n        console.log(`‚úÖ Eliminados ${batchDocs.length} documentos de ${collectionName}`);\n      }\n    }\n\n    console.log(`üéâ Limpieza completa! Total de documentos eliminados: ${totalDeleted}`);\n    return true;\n\n  } catch (error) {\n    console.error('‚ùå Error durante la limpieza:', error);\n    throw error;\n  }\n}\n\nexport async function createInitialStructures() {\n  console.log('üèóÔ∏è Creando estructuras iniciales...');\n  \n  try {\n    // No necesitamos crear documentos, solo las collections se crear√°n autom√°ticamente\n    // cuando agregemos el primer documento a cada una\n    \n    console.log('‚úÖ Estructuras iniciales listas');\n    console.log('üìù Las collections se crear√°n autom√°ticamente al agregar datos');\n    \n    return true;\n  } catch (error) {\n    console.error('‚ùå Error creando estructuras:', error);\n    throw error;\n  }\n}\n\n// Funci√≥n para crear datos de prueba\nexport async function createTestData() {\n  console.log('üß™ Creando datos de prueba...');\n  \n  // Esta funci√≥n la implementaremos despu√©s de la limpieza\n  return true;\n}\n\n// Funci√≥n principal que ejecuta todo el proceso\nexport async function resetDatabaseForP2P() {\n  try {\n    console.log('üöÄ Iniciando reset completo de base de datos para P2P...');\n    \n    // Paso 1: Limpiar todo\n    await cleanDatabase();\n    \n    // Paso 2: Crear estructuras\n    await createInitialStructures();\n    \n    // Paso 3: Crear datos de prueba (opcional)\n    // await createTestData();\n    \n    console.log('üéâ ¬°Reset completo exitoso!');\n    console.log('üìã La base de datos est√° lista para el sistema P2P');\n    \n    return true;\n    \n  } catch (error) {\n    console.error('‚ùå Error en el reset de base de datos:', error);\n    throw error;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}