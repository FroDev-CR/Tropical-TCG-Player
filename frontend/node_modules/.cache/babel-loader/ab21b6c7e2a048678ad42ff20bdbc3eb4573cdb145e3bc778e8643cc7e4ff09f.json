{"ast":null,"code":"// src/scripts/cleanDatabase.js\n// Script para limpiar completamente la base de datos Firebase\n\nimport { db } from '../firebase';\nimport { collection, getDocs, deleteDoc, doc, writeBatch } from 'firebase/firestore';\nexport async function cleanDatabase() {\n  console.log('üßπ Iniciando limpieza completa de la base de datos...');\n  const collections = ['users', 'listings', 'transactions', 'notifications', 'ratings', 'disputes', 'binders'];\n  try {\n    let totalDeleted = 0;\n    for (const collectionName of collections) {\n      console.log(`üóëÔ∏è Limpiando collection: ${collectionName}`);\n      const collectionRef = collection(db, collectionName);\n      const snapshot = await getDocs(collectionRef);\n      if (snapshot.empty) {\n        console.log(`‚úÖ Collection ${collectionName} ya est√° vac√≠a`);\n        continue;\n      }\n\n      // Usar batch para eliminar documentos en grupos de 500\n      const docs = snapshot.docs;\n      console.log(`üìä Encontrados ${docs.length} documentos en ${collectionName}`);\n      const batchSize = 500;\n      for (let i = 0; i < docs.length; i += batchSize) {\n        const batch = writeBatch(db);\n        const batchDocs = docs.slice(i, i + batchSize);\n        batchDocs.forEach(document => {\n          batch.delete(doc(db, collectionName, document.id));\n        });\n        await batch.commit();\n        totalDeleted += batchDocs.length;\n        console.log(`‚úÖ Eliminados ${batchDocs.length} documentos de ${collectionName}`);\n      }\n    }\n    console.log(`üéâ Limpieza completa! Total de documentos eliminados: ${totalDeleted}`);\n    return true;\n  } catch (error) {\n    console.error('‚ùå Error durante la limpieza:', error);\n    throw error;\n  }\n}\nexport async function createInitialStructures() {\n  console.log('üèóÔ∏è Creando estructuras iniciales...');\n  try {\n    // No necesitamos crear documentos, solo las collections se crear√°n autom√°ticamente\n    // cuando agregemos el primer documento a cada una\n\n    console.log('‚úÖ Estructuras iniciales listas');\n    console.log('üìù Las collections se crear√°n autom√°ticamente al agregar datos');\n    return true;\n  } catch (error) {\n    console.error('‚ùå Error creando estructuras:', error);\n    throw error;\n  }\n}\n\n// Funci√≥n para crear datos de prueba\nexport async function createTestData() {\n  console.log('üß™ Creando datos de prueba...');\n\n  // Esta funci√≥n la implementaremos despu√©s de la limpieza\n  return true;\n}\n\n// Funci√≥n principal que ejecuta todo el proceso\nexport async function resetDatabaseForP2P() {\n  try {\n    console.log('üöÄ Iniciando reset completo de base de datos para P2P...');\n\n    // Paso 1: Limpiar todo\n    await cleanDatabase();\n\n    // Paso 2: Crear estructuras\n    await createInitialStructures();\n\n    // Paso 3: Crear datos de prueba (opcional)\n    // await createTestData();\n\n    console.log('üéâ ¬°Reset completo exitoso!');\n    console.log('üìã La base de datos est√° lista para el sistema P2P');\n    return true;\n  } catch (error) {\n    console.error('‚ùå Error en el reset de base de datos:', error);\n    throw error;\n  }\n}","map":{"version":3,"names":["db","collection","getDocs","deleteDoc","doc","writeBatch","cleanDatabase","console","log","collections","totalDeleted","collectionName","collectionRef","snapshot","empty","docs","length","batchSize","i","batch","batchDocs","slice","forEach","document","delete","id","commit","error","createInitialStructures","createTestData","resetDatabaseForP2P"],"sources":["/home/frodev/Downloads/FroDev-CR-TropicalTCGPlayers/src/scripts/cleanDatabase.js"],"sourcesContent":["// src/scripts/cleanDatabase.js\n// Script para limpiar completamente la base de datos Firebase\n\nimport { db } from '../firebase';\nimport { collection, getDocs, deleteDoc, doc, writeBatch } from 'firebase/firestore';\n\nexport async function cleanDatabase() {\n  console.log('üßπ Iniciando limpieza completa de la base de datos...');\n  \n  const collections = [\n    'users',\n    'listings', \n    'transactions',\n    'notifications',\n    'ratings',\n    'disputes',\n    'binders'\n  ];\n\n  try {\n    let totalDeleted = 0;\n\n    for (const collectionName of collections) {\n      console.log(`üóëÔ∏è Limpiando collection: ${collectionName}`);\n      \n      const collectionRef = collection(db, collectionName);\n      const snapshot = await getDocs(collectionRef);\n      \n      if (snapshot.empty) {\n        console.log(`‚úÖ Collection ${collectionName} ya est√° vac√≠a`);\n        continue;\n      }\n\n      // Usar batch para eliminar documentos en grupos de 500\n      const docs = snapshot.docs;\n      console.log(`üìä Encontrados ${docs.length} documentos en ${collectionName}`);\n      \n      const batchSize = 500;\n      for (let i = 0; i < docs.length; i += batchSize) {\n        const batch = writeBatch(db);\n        const batchDocs = docs.slice(i, i + batchSize);\n        \n        batchDocs.forEach((document) => {\n          batch.delete(doc(db, collectionName, document.id));\n        });\n        \n        await batch.commit();\n        totalDeleted += batchDocs.length;\n        console.log(`‚úÖ Eliminados ${batchDocs.length} documentos de ${collectionName}`);\n      }\n    }\n\n    console.log(`üéâ Limpieza completa! Total de documentos eliminados: ${totalDeleted}`);\n    return true;\n\n  } catch (error) {\n    console.error('‚ùå Error durante la limpieza:', error);\n    throw error;\n  }\n}\n\nexport async function createInitialStructures() {\n  console.log('üèóÔ∏è Creando estructuras iniciales...');\n  \n  try {\n    // No necesitamos crear documentos, solo las collections se crear√°n autom√°ticamente\n    // cuando agregemos el primer documento a cada una\n    \n    console.log('‚úÖ Estructuras iniciales listas');\n    console.log('üìù Las collections se crear√°n autom√°ticamente al agregar datos');\n    \n    return true;\n  } catch (error) {\n    console.error('‚ùå Error creando estructuras:', error);\n    throw error;\n  }\n}\n\n// Funci√≥n para crear datos de prueba\nexport async function createTestData() {\n  console.log('üß™ Creando datos de prueba...');\n  \n  // Esta funci√≥n la implementaremos despu√©s de la limpieza\n  return true;\n}\n\n// Funci√≥n principal que ejecuta todo el proceso\nexport async function resetDatabaseForP2P() {\n  try {\n    console.log('üöÄ Iniciando reset completo de base de datos para P2P...');\n    \n    // Paso 1: Limpiar todo\n    await cleanDatabase();\n    \n    // Paso 2: Crear estructuras\n    await createInitialStructures();\n    \n    // Paso 3: Crear datos de prueba (opcional)\n    // await createTestData();\n    \n    console.log('üéâ ¬°Reset completo exitoso!');\n    console.log('üìã La base de datos est√° lista para el sistema P2P');\n    \n    return true;\n    \n  } catch (error) {\n    console.error('‚ùå Error en el reset de base de datos:', error);\n    throw error;\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}